{
    "collab_server" : "",
    "contents" : "# auxiliary check functions for mfa_gen()\ncheck_data <- function(data) {\n  if (class(data)!=\"data.frame\" & class(data)!=\"matrix\") {\n    stop(\"Data should be data frame or matrix\")\n  }\n  if (sum(!sapply(data,is.numeric))!=0) {\n    stop(\"Data is not numeric\")\n  }\n  TRUE\n}\n\n#### more to test\ncheck_sets <- function(sets) {\n  if (!sum(sapply(sets,is.numeric))!= 0){\n    TRUE\n  }else if (!sum(sapply(sets,is.character))!= 0){\n    TRUE\n  }else{\n    stop(\"sets should be all numeric or all character\")\n  }\n  }\n\n\ncheck_ncomps <- function(data, ncomps) {\n  if (!is.null(ncomps) & !is.numeric(ncomps)) {\n    stop(\"ncomps should be a numeric number!\")\n  }\n  if (!is.null(ncomps) & length(ncomps) != 1) {\n    stop(\"The length of ncomps should be 1!\")\n  }\n  if (!is.null(ncomps)) {\n    if (!ncomps %in% seq(from = 1, to = nrow(data), by = 1)) {\n      stop(paste(\"The value of ncomps should be between 1 and\", nrow(data)))\n    }\n  }\n  TRUE\n}\n\n# ------------------------------------\n\n#' @title Construct mfa\n#' @description Creates an object of class \\code{\"mfa\"}\n#' @param data dataset on which MFA is conducted\n#' @param sets list of vectors indicating the sets of variables (i.e. the blocks)\n#' @param ncomps integer indicating how many number of components (i.e. factors) are to be extracted\n#' @param center either a logical value or a numeric vector of length equal to the number of active variables in the analysis\n#' @param scale either a logical value or a numeric vector of length equal to the number of active variables in the analysis\n#' @return an object of class mfa\n#' @export\n#' @examples\n#' url=\"https://raw.githubusercontent.com/ucb-stat243/stat243-fall-2016/master/problem-sets/final-project/data/wines.csv\"\n#' data=read.csv(file=url, header = TRUE, sep = \",\")\n#' datanum <- data[,-1]\n#'\n#' # a list of numeric vectors with the position of the active variables in the data table.\n#' sets <- list(1:6, 7:12, 13:18, 19:23, 24:29, 30:34, 35:38, 39:44, 45:49, 50:53)\n#' # create object 'wine' of class mfa\n#' wine <- mfa_gen(data = datanum, sets = sets, ncomps = 2)\n\nmfa_gen <- function(data, sets, ncomps = NULL, center = TRUE, scale = TRUE) {\n  check_data(data)\n  check_sets(sets)\n  check_ncomps(data, ncomps)\n  #set ncomps\n  ncomps <- ifelse(is.null(ncomps), nrow(data), ncomps)\n\n\n  # store the weights\n  alpha <- NULL\n\n  # data.pro stores the normalized grand table\n  data.pro <- matrix(nrow=nrow(data), ncol=tail(sets[[length(sets)]],n=1))\n\n  # conduct SVD on each sub table\n  for (i in 1:length(sets)){\n    #decompose the grand table\n    dat <- data[,sets[[i]]]\n    #normalize subtable\n    dat <- scale(dat,center=center, scale= scale)/sqrt(nrow(data)-1)\n    data.pro[,sets[[i]]] <- dat\n\n    # SVD\n    s <- svd(dat)\n    alpha[i] <- 1/(s$d[1]^2)\n  }\n\n  # diagonal matrix\n  A <- diag(rep(alpha,lapply(sets,length)))\n\n\n  #compute m, p, q for gsvd\n  M <- diag(1/nrow(data),nrow=nrow(data))\n  gsvd <- svd(sqrt(M)%*%data.pro%*%sqrt(A))\n  P <- solve(sqrt(M))%*%gsvd$u\n  Q <- solve(sqrt(t(A)))%*%gsvd$v\n  D <- diag(gsvd$d)\n\n\n  # Full Factor Scores\n  Fscore <- P %*% D\n  # requested Factor Scores\n  Factorscore = P%*%D[,1:ncomps]\n\n\n  # partial factor scores\n  # create a list of matrix to store the PFS for each experts\n  partial.factor <- vector(\"list\", length(sets))\n  for (i in 1:length(sets)){\n    #decompose the processed data table\n    dat <- data.pro[,sets[[i]]]\n    partial.factor[[i]] <- length(sets)*alpha[i]*dat%*%Q[sets[[i]],1:ncomps]\n  }\n\n\n  # vector of eigenvalues\n  eigenvalues <- diag(D)^2\n\n  # create the object mfa\n  object <- list(\"eigenvalues\" = eigenvalues, \"FactorScore\" = Factorscore,\n                 \"PartialFactorScores\" = partial.factor, \"Loadings\" = Q[,1:ncomps],\n                 \"MatrixA\" = A, \"sets\" = sets)\n  class(object) <- \"mfa\"\n  return(object)\n}\n\n\n\n\n# ---------------------------------\n# General check functions\n# ---------------------------------\n\ncheck_data <- function(data) {\n  if (class(data)!=\"data.frame\" & class(data)!=\"matrix\") {\n    stop(\"Data should be data frame or matrix\")\n  }\n  if (sum(!sapply(data,is.numeric))!=0) {\n    stop(\"Data is not numeric\")\n  }\n  TRUE\n}\n\n\n#### more to test\ncheck_sets <- function(sets) {\n  if (sum(!sapply(sets,is.numeric))!= 0 & sum(!sapply(sets,is.character))!= 0) {\n    stop(\"Sets should be all numeric or all character vector\")\n  }\n  TRUE\n}\n\n\ncheck_ncomps <- function(data, ncomps) {\n  if (!is.null(ncomps) & !is.numeric(ncomps)) {\n    stop(\"ncomps should be a numeric number!\")\n  }\n  if (!is.null(ncomps) & length(ncomps) != 1) {\n    stop(\"The length of ncomps should be 1!\")\n  }\n  if (!is.null(ncomps)) {\n    if (!ncomps %in% seq(from = 1, to = nrow(data), by = 1)) {\n      stop(paste(\"The value of ncomps should be between 1 and\", nrow(data)))\n    }\n  }\n  TRUE\n}\n\n#check numeric\ncheck_numeric <- function(x){\n  if(sum(!sapply(x,is.numeric))!=0){\n    stop(\"Argument is not numeric\")\n    }\n  TRUE\n}\n\n# ===============================\n# print method\n# ===============================\n\n# ---------------------------------\n# Auxiliary check function for plot method\n# ---------------------------------\ncheck_subtable <- function(subtable) {\n  if (!is.numeric(subtable) & !is.null(subtable)) {\n    stop(\"subtable should be either a numeric value or NULL\")\n  }\n  TRUE\n}\n\n# ---------------------------------\n#' @title Print method for object of class \\code{\"mfa\"}\n#' @description Print out the eigenvalues and partial factor score of the specified subtable\n#' @param object mfa object\n#' @param subtable if subtable = NULL then no partial factor score will be printed; if subtable is a numerical value, then the partical factor score for the subtable of this index is printed\n#' @return Printed eigenvalues and partical factor score\n#' @export\n#' @examples\n#' # print the eigenvalues\n#' print(wine)\n#'\n#' # print the eigenvalues and the partical factor scores for the 6th subtable\n#' print(wine, subtable = 6)\n\nprint.mfa <- function(object, subtable = NULL, ...) {\n\n  check_subtable(subtable)\n  # print eignvalues\n  cat('Eigenvalues (listed in the order of components) \\n')\n  e = matrix(round(object$eigenvalues, 3), nrow = 1, ncol = length(object$eigenvalues))\n  # change the row names and column names of the matrix\n  rownames(e) = \"\"\n  colnames(e) = 1:length(object$eigenvalues)\n  print(e)\n\n  cat(\"\\n\")\n\n  # print partial factor scores if subtable index is indicated\n  if (class(subtable) == \"numeric\") {\n    cat(paste('Partial Factor Score Matrix for Assessor No.', subtable, '\\n', sep = \"\"))\n\n    # change the row names and column names of the matrix\n    rownames(object$`PartialFactorScores`[[subtable]]) = 1:length(object$eigenvalues)\n    colnames(object$`PartialFactorScores`[[subtable]]) = 1:ncol(object$Loadings)\n    # print the matrix\n    print(object$`PartialFactorScores`[[subtable]])\n  }\n\n  # hide the default description of object\n  invisible(object)\n}\n\n# ===============================\n# summaries of eigenvalues\n# ===============================\n\n#' @title Eigenvalue summary for object of class \\code{\"mfa\"}\n#' @description Creates a table that summarizes information about the obtained eigenvalues\n#' @param object mfa object\n#' @return a table with singular values, the eigenvalues, cumulative, percentage of intertia, cumulative percentage of inertia, for all the extracted components.\n#' @export\n#' @examples\n#' eigen(wine)\n\neigen <- function(x) UseMethod(\"eigen\")\n\neigen.mfa <- function(x){\n  eigenvalue <- round(as.numeric(x$eigenvalues),3)\n  singular <- round(sqrt(eigenvalue),3)\n  cumulative <- cumsum(eigenvalue)\n  intertia <- round(eigenvalue/sum(eigenvalue)*100,0)\n  cumulative.intertia <- cumsum(intertia)\n  eigenvalue.table <- t(data.frame(singular,eigenvalue,cumulative, intertia, cumulative.intertia))\n  colnames(eigenvalue.table) <- 1:length(eigenvalue)\n  return(eigenvalue.table)\n}\n\n# ===============================\n# contributions\n# ===============================\n\n#' @title Contribution of observations\n#' @description Calculates the contributions of the observations to the extracted components (dimensions)\n#' @param object mfa object\n#' @return a matrix with its [i,j] element be the contribution of the ith observation to the jth component\n#' @export\n#' @examples\n#' contri_obs(wine)\n\n# Define the generic function\ncontri_obs <- function(x, ...) UseMethod(\"contri_obs\")\n\ncontri_obs.mfa <- function(x) {\n  # Get the eigenvalues\n  lambda <- x$eigenvalues[1:ncol(x$Loadings)]\n  # Inverse the eigenvalues\n  inv_lambda <- lambda^(-1)\n  # Matrix of mass\n  M <- diag(1/length(x$eigenvalues),nrow=length(x$eigenvalues))\n  # Square the factor scores\n  F_squared <- (x$FactorScore)^2\n  # Contribution of an observation to a dimension\n  ctr_obs <- M %*% F_squared * inv_lambda\n\n  return(ctr_obs)\n}\n\n#' @title Contribution of variables\n#' @description Calculates the contributions of the variables to the extracted components (dimensions)\n#' @param object mfa object\n#' @return a matrix with its [i,j] element be the contribution of the ith variable to the jth component\n#' @export\n#' @examples\n#' contri_var(wine)\n\n# Define the generic function\ncontri_var <- function(x, ...) UseMethod(\"contri_var\")\n\ncontri_var.mfa <- function(x) {\n  # Matrix A\n  A <- x$MatrixA\n  # Square the loadings\n  Q_squared <- (x$Loadings)^2\n  # Contribution of a variable to a dimension\n  ctr_var <- A %*% Q_squared\n\n  return (ctr_var)\n}\n\n#' @title Contribution of subtables\n#' @description Calculates the contributions of the subtables to the extracted components (dimensions)\n#' @param object mfa object\n#' @return a matrix with its [i,j] element be the contribution of the ith subtable to the jth component\n#' @export\n#' @examples\n#' contri_table(wine)\n\n# Define the generic function\ncontri_table <- function(x, ...) UseMethod(\"contri_table\")\n\ncontri_table.mfa <- function(x) {\n  # Matrix A\n  A <- x$MatrixA\n  # Square the loadings\n  Q_squared <- (x$Loadings)^2\n  # Contribution of a variable to a dimension\n  ctr_var <- A %*% Q_squared\n  # Get the sets\n  set <- x$sets\n  ctr_table <- matrix(nrow = length(set), ncol = ncol(ctr_var))\n  for (i in 1:length(set)) {\n    ctr_table[i,] <- colSums(ctr_var[set[[i]],])\n  }\n  return(ctr_table)\n}\n\n# ===============================\n# Rv coefficient\n# ===============================\n\n# Auxiliary function to calculate RV coefficient for 2 tables\nRV <- function(table1,table2){\n  check_numeric(table1)\n  check_numeric(table2)\n\n  table1 <- as.matrix(table1)\n  table2 <- as.matrix(table2)\n  numerator <- sum(diag((table1 %*% t(table1)) %*% (table2 %*% t(table2))))\n  denominator <- sqrt((sum(diag((table1 %*% t(table1)) %*% (table1 %*% t(table1))))) * (sum(diag((table2 %*% t(table2)) %*% (table2 %*% t(table2))))))\n  return(numerator/denominator)\n}\n\n\n#' @title Rv coefficient\n#' @description Calculates the Rv coefficients between the specified subtables in a grand table\n#' @param dataset the grand table from which subtables are extracted\n#' @param sets list of numeric vectors that extract subtables from the grand table. The ith vector of the list represents the ith subtable extracted\n#' @return a matrix with its [i,j] element be the Rv coefficient between the ith subtable and the jth subtable\n#' @export\n#' @examples\n#' RV_table(datanum, sets = list(sets[[1]], sets[[2]]))\n\nRV_table <- function(dataset, sets){\n\n  check_data(dataset)\n  check_sets(sets)\n\n  k <- length(sets)\n  table <- matrix(nrow= k, ncol= k)\n  for (i in 1:k){\n    for (j in 1:k){\n      table[i,j] <- RV(dataset[,sets[[i]]], dataset[,sets[[j]]])\n    }\n  }\n  return(table)\n}\n\n# ===============================\n# Lg coefficient\n# ===============================\n\n# Auxiliary function to calculate Lg coefficient for 2 tables\nLg <- function(table1,table2,alpha1,alpha2){\n\n  check_numeric(table1)\n  check_numeric(table2)\n  check_numeric(alpha1)\n  check_numeric(alpha2)\n\n  table1 <- as.matrix(table1)\n  table2 <- as.matrix(table2)\n  s <- sum(diag((table1 %*% t(table1)) %*% (table2 %*% t(table2))))\n  return(s*alpha1*alpha2)\n}\n\n#' @title Lg coefficient\n#' @description Calculates the Lg coefficients between the specified subtables in a grand table\n#' @param dataset the grand table from which subtables are extracted\n#' @param sets list of numeric vectors that extract subtables from the grand table. The ith vector of the list represents the ith subtable extracted\n#' @return a matrix with its [i,j] element be the Lg coefficient between the ith subtable and the jth subtable\n#' @export\n#' @examples\n#' Lg_table(datanum, sets = list(sets[[1]], sets[[2]]))\n\nLg_table <- function(dataset, sets){\n\n  check_data(dataset)\n  check_sets(sets)\n\n  k <- length(sets)\n  table <- matrix(nrow= k, ncol= k)\n  for (i in 1:k){\n    for (j in 1:k){\n      gam1 <- svd(dataset[,sets[[i]]])$d[1]\n      gam2 <- svd(dataset[,sets[[j]]])$d[1]\n      a1 <- 1/(gam1^2)\n      a2 <- 1/(gam2^2)\n      table[i,j] <- Lg(dataset[,sets[[i]]], dataset[,sets[[j]]], alpha1 = a1, alpha2 = a2)\n    }\n  }\n  return(table)\n}\n\n# ===============================\n# Bootstrap\n# ===============================\n\n# Auxiliary function for bootstrapping one a time\nbootstrapprep=function(userset,dataset,ncomp){\n  bootPfactorscore=mfa_gen(dataset,sets=userset,ncomps =ncomp)$PartialFactorScores\n  XB=sample(1:length(userset),length(userset),replace=TRUE)\n  add=matrix(0,nrow = nrow(dataset),ncol=ncomp)\n  for (i in 1:length(XB)){\n    Factor=bootPfactorscore[[XB[i]]]\n    add=add+Factor\n    Fboot=1/length(XB)*add\n  }\n  return (Fboot)\n}\n\n#' @title Bootstrap for object of class \\code{\"mfa\"}\n#' @description Perform bootstrap in order to estimate the stability of the compromise factor scores\n#' @param L size of the bootstrap sample\n#' @param userset list of vectors indicating the way to partition the grand table into subtables\n#' @param dataset the grand table\n#' @param ncomps integer indicating how many number of components (i.e. factors) are to be extracted\n#' @return matrix of bootstrap ratios\n#' @export\n#' @examples\n#' sets <- list(1:6, 7:12, 13:18, 19:23, 24:29, 30:34, 35:38, 39:44, 45:49, 50:53)\n#' bootstrap(1000,sets,datanum,2)\n\n# bootstrap by L times\nbootstrap=function(L,userset,dataset,ncomp){\n  check_numeric(L)\n  check_sets(userset)\n  check_data(dataset)\n  check_ncomps(ncomp)\n\n  Fl=matrix(0,nrow = nrow(dataset),ncol=ncomp)\n  Fstar=list()\n  for (k in 1:L){\n    Fstar[[k]]=bootstrapprep(userset,dataset,ncomp)\n    Fl=Fl+Fstar[[k]]\n  }\n  #mean\n  L=1000\n  F.starbar=1/L*Fl\n  #std\n  F.starstdsum=matrix(0,nrow = nrow(datanum),ncol=2)\n  for (k in 1:L){\n    F.starstdsum=F.starstdsum+(F.starbar-Fstar[[k]])^2\n  }\n  F.starstd=sqrt(1/L*F.starstdsum)\n  #Ratio\n  T.star=F.starbar * F.starstd^(-1)\n  return (T.star)\n}\n\n\n\n# ---------------------------------\n# Auxiliary check function for plot method\n# ---------------------------------\ncheck_dim <- function(mfa, dim1, dim2) {\n  if (!is.numeric(dim1) | !is.numeric(dim2)) {\n    stop(\"dim1 and dim2 should be numeric!\")\n  }\n  if (length(dim1) != 1 | length(dim2) != 1) {\n    stop(\"The length of dim1 and dim2 should be 1\")\n  }\n  if (!dim1 %in% seq(from = 1, to = ncol(mfa$FactorScore), by = 1) | !dim2 %in% seq(from = 1, to = nrow(mfa$FactorScore), by = 1)) {\n    stop(paste(\"dim1 and dim2 should be between 1 and\", ncol(mfa$FactorScore)))\n  }\n  TRUE\n}\n\ncheck_type <- function(type) {\n  if (!is.numeric(type)) {\n    stop(\"type should be a numeric value\")\n  }\n\n  if(length(type) != 1) {\n    stop(\"The length of type should be 1!\")\n  }\n\n  if (!type %in% c(1,2,3,4)) {\n    stop(\"type should be numeric value 1, 2, 3, or 4!\")\n  }\n  TRUE\n}\n\ncheck_text <- function(mfa, text) {\n  if (!is.null(text) & length(text) != nrow(mfa$Loadings)) {\n    stop(paste(\"The length of text should be\", nrow(mfa$Loadings)))\n  }\n  TRUE\n}\n\ncheck_cat <- function(mfa, cat) {\n  if (!is.null(cat) & sum(sapply(cat, length)) != nrow(mfa$FactorScore)) {\n    stop(paste(\"The total number of elements in cat should be\", nrow(mfa$FactorScore)))\n  }\n  TRUE\n}\n\n\n# ---------------------------------\n# Auxiliary functions for plot method\n# ---------------------------------\n# only plot the partial factor score of one applicant\nplot_pfs <- function(mfa, dim1, dim2, index, cat = NULL) {\n  pfs <- as.data.frame(mfa$PartialFactorScores[[index]])\n  x <- pfs[,dim1]\n  y <- pfs[,dim2]\n  xlab <- paste0(\"comp\", dim1)\n  ylab <- paste0(\"comp\", dim2)\n  title <- paste(\"Partial Factor Score for Subtable\", index)\n  if(!is.null(cat)) {\n    indicator <- NULL\n    for (i in 1:length(cat)) {\n      if (is.null(names(cat))) {\n        indicator[cat[[i]]] <- rep(i, length(cat[i]))\n      }\n      else {\n        indicator[cat[[i]]] <- names(cat)[i]\n      }\n    }\n    pfs$category <- factor(indicator)\n    ggplot() + geom_point(data = pfs, aes(x = x, y = y, col = category, group = category)) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + labs(title = title, x = xlab, y = ylab)\n  }\n  else {\n    ggplot() + geom_point(data = pfs, aes(x = x, y = y)) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + geom_text(data = pfs, aes(x = x, y = y, label = rownames(pfs)), hjust = 0, nudge_x = 0.05) + labs(title = title, x = xlab, y = ylab)\n  }\n}\n\n\n# only plot the loadings of one applicant\nplot_loadings <- function(mfa, dim1, dim2, index, text = NULL) {\n  sets <- mfa$sets\n  loadings <- as.data.frame(mfa$Loadings[sets[[index]],])\n  xlab <- paste0(\"loading\", dim1)\n  ylab <- paste0(\"loading\", dim2)\n  title <- paste(\"Loadings for Subtable\", index)\n  if (!is.null(text)) {\n    row.names(loadings) <- text[sets[[index]]]\n  }\n  loadings[,dim1] <- loadings[,dim1]*sqrt(wine$eigenvalues[dim1])/sd(loadings[,dim1])\n  loadings[,dim2]<- loadings[,dim2]*sqrt(wine$eigenvalues[dim2])/sd(loadings[,dim2])\n  ggplot() + geom_point(data = loadings, aes(x=loadings[,dim1], y=loadings[,dim2])) + geom_text(data = loadings, aes(x=loadings[,dim1], y=loadings[,dim2], label = rownames(loadings)), hjust = 0, nudge_x = 0.05) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + labs(title = title, x = xlab, y = ylab)\n}\n\n\n# plot the partial factor score and loadings of one applicant\nplot_pfsl <- function(mfa, dim1, dim2, index, text = NULL, cat = NULL) {\n  pfs <- as.data.frame(mfa$PartialFactorScores[[index]])\n  x <- pfs[,dim1]\n  y <- pfs[,dim2]\n  xlab <- paste0(\"comp\", dim1)\n  ylab <- paste0(\"comp\", dim2)\n  title <- paste(\"Partial Factor Score and Loadings for Subtable\", index)\n\n  # loadings\n  sets <- mfa$sets\n  loadings <- as.data.frame(mfa$Loadings[sets[[index]],])\n  loadings[,dim1] <- loadings[,dim1]*sqrt(wine$eigenvalues[dim1])/sd(loadings[,dim1])\n  loadings[,dim2]<- loadings[,dim2]*sqrt(wine$eigenvalues[dim2])/sd(loadings[,dim2])\n  if (!is.null(text)) {\n    row.names(loadings) <- text[sets[[index]]]\n  }\n\n  # pfs\n  if(!is.null(cat)) {\n    indicator <- NULL\n    for (i in 1:length(cat)) {\n      if (is.null(names(cat))) {\n        indicator[cat[[i]]] <- rep(i, length(cat[i]))\n      }\n      else {\n        indicator[cat[[i]]] <- names(cat)[i]\n      }\n    }\n    pfs$category <- factor(indicator)\n    ggplot() +  geom_point(data = pfs, aes(x = x, y = y, col = category, group = category)) + geom_point(data = loadings, aes(x=loadings[,dim1], y=loadings[,dim2])) + geom_text(data = loadings, aes(x=loadings[,dim1], y=loadings[,dim2], label = rownames(loadings)), hjust = 0, nudge_x = 0.05) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0) + labs(title = title, x = xlab, y = ylab)\n  }\n\n\n  # change the color\n  else {\n    ggplot() + geom_point(data = pfs, aes(x = x, y = y, col = \"Partial Factor Scores\")) + geom_text(data = pfs, aes(x = x, y = y, label = rownames(pfs)), hjust = 0, nudge_x = 0.05) + geom_point(data = loadings, aes(x=loadings[,dim1], y=loadings[,dim2], col = \"Loadings\")) + geom_text(data = loadings, aes(x=loadings[,dim1], y=loadings[,dim2], label = rownames(loadings)), hjust = 0, nudge_x = 0.05) + geom_hline(yintercept = 0) + geom_vline(xintercept = 0)  + scale_color_manual(name= \"Legend\", breaks=c(\"Partial Factor Scores\", \"Loadings\"), values = c(\"red\", \"black\")) + labs(title = title, x = xlab, y = ylab)\n  }\n}\n\n#-----------------------------------\n\n#' @title Plot Method for object of class \\code{\"mfa\"}\n#' @description Plots graphs of factor scores (the compromise of the tables), of partial factor scores, or of variable loadings given two dimensions\n#' @param object mfa object to be plotted\n#' @param cat categories to group the observations\n#' @param text lables for variables\n#' @param dim1 numeric value that determines the 1st PC the user chooses\n#' @param dim2 numeric value that determines the 2nd PC the user chooses\n#' @param type numeric value that:\n#'                if it is 1, then plot the factor scores\n#'                if it is 2, then plot the partial factor scores\n#'                if it is 3, then plot the loadings\n#'                if it is 4, then plot the partial factor scores and variable loadings\n#' @return Given the choice of type, return graphs of factor scores (the compromise of the tables), of partial factor scores, or of variable loadings\n#' @export\n#' @examples\n#' cat <- list(\"New Zealand\" = 1:4, \"Canada\" = 5:8, \"France\" = 9:12)\n#' dftext <- c(\"Cat Pee\", \"Passion Fruit\", \"Green Pepper\",\n#'             \"Mineral\", \"Smoky\", \"Cirtrus\", \"Cat Pee\",\n#'             \"Passion Fruit\", \"Green Pepper\", \"Mineral\",\n#'             \"Tropical\", \"Leafy\", \"Cat Pee\", \"Passion Fruit\", \"Green Pepper\",\n#'             \"Mineral\", \"Grassy\", \"Flinty\", \"Cat Pee\", \"Passion Fruit\", \"Green Pepper\",\n#'             \"Mineral\", \"Leafy\", \"Cat Pee\", \"Passion Fruit\", \"Green Pepper\", \"Mineral\",\n#'             \"Vegetal\", \"Hay\", \"Cat Pee\", \"Passion Fruit\", \"Green Pepper\", \"Mineral\",\n#'             \"Melon\", \"Cat Pee\", \"Passion Fruit\", \"Green Pepper\", \"Mineral\", \"Cat Pee\",\n#'             \"Passion Fruit\", \"Green Pepper\", \"Mineral\", \"Grass\", \"Smoky\", \"Cat Pee\",\n#'             \"Passion Fruit\", \"Green Pepper\", \"Mineral\", \"Peach\", \"Cat Pee\",\n#'             \"Passion Fruit\", \"Green Pepper\", \"Mineral\")\n#' plot(mfa = wine, cat = cat, dim1 = 1, dim2 = 2, type = 1, text = dftext)\n#' plot(mfa = wine, cat = cat, dim1 = 1, dim2 = 2, type = 2, text = dftext)\n#' plot(mfa = wine, dim1 = 1, dim2 = 2, type = 3)\n\nplot.mfa <- function(mfa, dim1, dim2, type, text = NULL, cat = NULL) {\n\n  # check argument\n  check_dim(mfa, dim1, dim2)\n  check_type(type)\n  check_text(mfa, text)\n  check_cat(mfa, cat)\n\n  # Plot factor scores\n  if (type == \"1\") {\n    fs <- as.data.frame(mfa$FactorScore)\n    comp1 <- fs[,dim1]\n    comp2 <- fs[,dim2]\n    xlab <- paste0(\"comp\", dim1)\n    ylab <- paste0(\"comp\", dim2)\n    category <- NULL\n    for (i in 1:length(cat)) {\n      category[cat[[i]]] <- names(cat)[i]\n    }\n    fs$Category <- factor(category)\n    graph <- ggplot()\n    # Plot factor scores\n    graph + geom_point(data = fs, aes(x = comp1, y = comp2, col = Category,\n                                      group = Category)) +\n      geom_hline(yintercept = 0) + geom_vline(xintercept = 0) +\n      labs(title = \"Factor Scores\", x = xlab, y = ylab)\n  }\n\n  # Plot partial factor scores\n  else if (type == \"2\") {\n    for (i in 1:length(mfa$sets)) {\n      print(plot_pfs(mfa, dim1, dim2, i, cat))\n    }\n  }\n\n  else if (type == \"3\") {\n    for (i in 1:length(mfa$sets)) {\n      print(plot_loadings(mfa, dim1, dim2, i, text))\n    }\n  }\n\n  else if (type == \"4\") {\n    for (i in 1:length(mfa$sets)) {\n      print(plot_pfsl(mfa, dim1, dim2, i, text, cat))\n    }\n  }\n}\n\n\n\n",
    "created" : 1480462176665.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1679045952",
    "id" : "6CCA385C",
    "lastKnownWriteTime" : 1480463185,
    "last_content_update" : 1480463185855,
    "path" : "~/Desktop/234 final/MFA/R/mfa.R",
    "project_path" : "R/mfa.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}